// Generic Constraints (T extends X) â€” positive tests

def firstString<T extends string>(value: T): T {
  return value
}

def wrapNumber<T extends number>(value: T): T {
  return value
}

def pairConstrained<T extends string, U extends number>(s: T, n: U): T {
  return s
}

test('constraint allows compatible argument', () => {
  result = firstString('hello')
  expect(result).toBe('hello')
})

test('constraint allows compatible number argument', () => {
  result = wrapNumber(42)
  expect(result).toBe(42)
})

test('function with multiple constraints', () => {
  result = pairConstrained('text', 10)
  expect(result).toBe('text')
})

test('constraint with union bound', () => {
  def firstStringOrNull<T extends string | null>(value: T): T {
    return value
  }
  r1 = firstStringOrNull('hello')
  r2 = firstStringOrNull(null)
  expect(r1).toBe('hello')
  expect(r2).toBe(null)
})
