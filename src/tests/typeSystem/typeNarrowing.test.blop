
// Type narrowing tests

// Test 1: Basic typeof string narrowing
def processString(val: string | number): string {
  if typeof val == 'string' {
    return val.toUpperCase()
  } else {
    return val.toString()
  }
}

// Test 2: typeof number narrowing
def processNumber(val: string | number): number {
  if typeof val == 'number' {
    return val * 2
  } else {
    return parseInt(val)
  }
}

// Test 3: typeof with null
def handleNullable(val: string | null): string {
  if typeof val == 'string' {
    return val.toUpperCase()
  } else {
    return 'null value'
  }
}

// Test 4: typeof with undefined
def handleOptional(val: number | undefined): number {
  if typeof val == 'number' {
    return val + 10
  } else {
    return 0
  }
}

// Test 5: typeof boolean
def handleBoolean(val: boolean | string): string {
  if typeof val == 'boolean' {
    if val {
      return 'true'
    } else {
      return 'false'
    }
  } else {
    return val
  }
}

// Test 6: typeof object
def handleObject(val: object | string): string {
  if typeof val == 'object' {
    return 'is object'
  } else {
    return val
  }
}

// Test 7: Multiple unions
def handleMultiple(val: string | number | boolean): string {
  if typeof val == 'string' {
    return val.toUpperCase()
  } elseif typeof val == 'number' {
    return val.toString()
  } else {
    return 'boolean'
  }
}

// Test 8: Works with else branch
def useElseBranch(val: string | number): string {
  if typeof val == 'number' {
    return 'number: 'val.toString()
  } else {
    return val.toUpperCase()
  }
}

// The type narrowing needs to persist AFTER the if block for code that follows, regardless of whether the if block returns. 

// Test 9: Type narrowing with undefined guard
def undefinedGuardBranch(val: string | undefined): string {
  if typeof val == 'undefined' {
    return ''
  }
  return val.toUpperCase()
}

// Test 10: Type narrowing with number guard
def numberGuardBranch(val: string | number): string {
  if typeof val == 'number' {
    return val.toString()
  }
  return val.toUpperCase()
}


test('typeof narrowing with string', () => {
  expect(processString('hello')).toBe('HELLO')
  expect(processString(42)).toBe('42')
})

test('typeof narrowing with number', () => {
  expect(processNumber(21)).toBe(42)
  expect(processNumber('10')).toBe(10)
})

test('typeof narrowing with null', () => {
  expect(handleNullable('test')).toBe('TEST')
  expect(handleNullable(null)).toBe('null value')
})

test('typeof narrowing with undefined', () => {
  expect(handleOptional(5)).toBe(15)
  expect(handleOptional(undefined)).toBe(0)
})

test('typeof narrowing with boolean', () => {
  expect(handleBoolean(true)).toBe('true')
  expect(handleBoolean(false)).toBe('false')
  expect(handleBoolean('text')).toBe('text')
})

test('typeof narrowing with object', () => {
  expect(handleObject({})).toBe('is object')
  expect(handleObject('text')).toBe('text')
})

test('typeof narrowing with multiple types', () => {
  expect(handleMultiple('test')).toBe('TEST')
  expect(handleMultiple(42)).toBe('42')
  expect(handleMultiple(true)).toBe('boolean')
})

test('typeof narrowing in else branch', () => {
  expect(useElseBranch(42)).toBe('number: 42')
  expect(useElseBranch('hello')).toBe('HELLO')
})

test('type narrowing persists after early-return undefined guard', () => {
  expect(undefinedGuardBranch('hello')).toBe('HELLO')
  expect(undefinedGuardBranch(undefined)).toBe('')
})

test('type narrowing persists after early-return number guard', () => {
  expect(numberGuardBranch(42)).toBe('42')
  expect(numberGuardBranch('hello')).toBe('HELLO')
})

// ── Equality narrowing ───────────────────────────────────────────────────────

// Test 12: null equality guard — early return
def nullEqGuard(val: string | null): string {
  if val == null {
    return 'was null'
  }
  return val.toUpperCase()
}

// Test 13: null equality guard — else branch
def nullEqGuardElse(val: string | null): string {
  if val == null {
    return 'was null'
  } else {
    return val.toUpperCase()
  }
}

// Test 14: undefined equality guard — early return
def undefinedEqGuard(val: string | undefined): string {
  if val == undefined {
    return 'was undefined'
  }
  return val.toUpperCase()
}

// Test 15: undefined equality guard — else branch
def undefinedEqGuardElse(val: string | undefined): string {
  if val == undefined {
    return 'was undefined'
  } else {
    return val.toUpperCase()
  }
}

// Test 16: null guard narrows in the if-branch too (val is null inside)
def nullBranchAccess(val: string | null): string {
  if val == null {
    return 'null'
  }
  return val.toUpperCase()
}

// Test 17: equality guard — else branch sees narrowed-out type
def shortIf(val: string | null): string {
  value = if val == null => 'null str' else val
  return value.toUpperCase()
}

// Test 18: typeof guard in short-if
def shortIfTypeof(val: string | number): string {
  value = if typeof val == 'number' => val.toString() else val.toUpperCase()
  return value
}

// Test 19: undefined equality guard in short-if
def shortIfUndefined(val: string | undefined): string {
  value = if val == undefined => 'none' else val.toUpperCase()
  return value
}

// Test 20: short-if used directly as return expression
def shortIfReturn(val: string | null): string {
  return if val == null => 'null str' else val.toUpperCase()
}

// Test 21: short-if without else branch (no-else form: if cond => expr)
def shortIfNoElse(val: number): number {
  return if val < 0 => 0 - val else val
}

test('equality narrowing: null guard early return', () => {
  expect(nullEqGuard('hello')).toBe('HELLO')
  expect(nullEqGuard(null)).toBe('was null')
})

test('equality narrowing: null guard else branch', () => {
  expect(nullEqGuardElse('world')).toBe('WORLD')
  expect(nullEqGuardElse(null)).toBe('was null')
})

test('equality narrowing: undefined guard early return', () => {
  expect(undefinedEqGuard('hi')).toBe('HI')
  expect(undefinedEqGuard(undefined)).toBe('was undefined')
})

test('equality narrowing: undefined guard else branch', () => {
  expect(undefinedEqGuardElse('bye')).toBe('BYE')
  expect(undefinedEqGuardElse(undefined)).toBe('was undefined')
})

test('equality narrowing: null branch access', () => {
  expect(nullBranchAccess('test')).toBe('TEST')
  expect(nullBranchAccess(null)).toBe('null')
})

// ── Equality narrowing in short-if expressions (if cond => x else y) ────────

test('equality narrowing in short-if else branch', () => {
  expect(shortIf('hello')).toBe('HELLO')
  expect(shortIf(null)).toBe('NULL STR')
})

test('typeof narrowing in short-if', () => {
  expect(shortIfTypeof(42)).toBe('42')
  expect(shortIfTypeof('hi')).toBe('HI')
})

test('undefined equality narrowing in short-if', () => {
  expect(shortIfUndefined('world')).toBe('WORLD')
  expect(shortIfUndefined(undefined)).toBe('none')
})

test('short-if used directly as return expression', () => {
  expect(shortIfReturn('hello')).toBe('HELLO')
  expect(shortIfReturn(null)).toBe('null str')
})

test('short-if without else branch', () => {
  expect(shortIfNoElse(5)).toBe(5)
  expect(shortIfNoElse(0 - 3)).toBe(3)
})

// ── Negated type guards (!= / !==) ──────────────────────────────────────────

// Test 22: Negated typeof — if-branch is the non-checked type
def notNumber(val: string | number): string {
  if typeof val != 'number' {
    return val.toUpperCase()
  } else {
    return val.toString()
  }
}

// Test 23: Negated equality — val != null narrows if-branch to non-null
def notNull(val: string | null): string {
  if val != null {
    return val.toUpperCase()
  } else {
    return 'was null'
  }
}

// Test 24: Negated equality early return — after guard, val is null
def notNullEarlyReturn(val: string | null): string {
  if val != null {
    return val.toUpperCase()
  }
  return 'was null'
}

// ── Truthiness narrowing (if val { }) ───────────────────────────────────────

// Test 25: Truthiness — if-branch strips null, giving string
def truthinessNarrowing(val: string | null): string {
  if val {
    return val.toUpperCase()
  } else {
    return 'falsy'
  }
}

// Test 26: Truthiness with undefined + early return
def truthinessEarlyReturn(val: string | undefined): string {
  if val {
    return val.toUpperCase()
  }
  return 'was falsy'
}

test('negated typeof guard', () => {
  expect(notNumber('hello')).toBe('HELLO')
  expect(notNumber(42)).toBe('42')
})

test('negated equality guard (else branch)', () => {
  expect(notNull('world')).toBe('WORLD')
  expect(notNull(null)).toBe('was null')
})

test('negated equality guard (early return)', () => {
  expect(notNullEarlyReturn('hi')).toBe('HI')
  expect(notNullEarlyReturn(null)).toBe('was null')
})

test('truthiness narrowing (if val)', () => {
  expect(truthinessNarrowing('test')).toBe('TEST')
  expect(truthinessNarrowing(null)).toBe('falsy')
})

test('truthiness narrowing with undefined early return', () => {
  expect(truthinessEarlyReturn('foo')).toBe('FOO')
  expect(truthinessEarlyReturn(undefined)).toBe('was falsy')
})
