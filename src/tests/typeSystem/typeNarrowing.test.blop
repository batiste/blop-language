
// Type narrowing tests

// Test 1: Basic typeof string narrowing
def processString(val: string | number): string {
  if typeof val == 'string' {
    return val.toUpperCase()
  } else {
    return val.toString()
  }
}

// Test 2: typeof number narrowing
def processNumber(val: string | number): number {
  if typeof val == 'number' {
    return val * 2
  } else {
    return parseInt(val)
  }
}

// Test 3: typeof with null
def handleNullable(val: string | null): string {
  if typeof val == 'string' {
    return val.toUpperCase()
  } else {
    return 'null value'
  }
}

// Test 4: typeof with undefined
def handleOptional(val: number | undefined): number {
  if typeof val == 'number' {
    return val + 10
  } else {
    return 0
  }
}

// Test 5: typeof boolean
def handleBoolean(val: boolean | string): string {
  if typeof val == 'boolean' {
    if val {
      return 'true'
    } else {
      return 'false'
    }
  } else {
    return val
  }
}

// Test 6: typeof object
def handleObject(val: object | string): string {
  if typeof val == 'object' {
    return 'is object'
  } else {
    return val
  }
}

// Test 7: Multiple unions
def handleMultiple(val: string | number | boolean): string {
  if typeof val == 'string' {
    return val.toUpperCase()
  } elseif typeof val == 'number' {
    return val.toString()
  } else {
    return 'boolean'
  }
}

// Test 8: Works with else branch
def useElseBranch(val: string | number): string {
  if typeof val == 'number' {
    return 'number: 'val.toString()
  } else {
    return val.toUpperCase()
  }
}

// The type narrowing needs to persist AFTER the if block for code that follows, regardless of whether the if block returns. 

// Test 9: Type narrowing with undefined guard
def undefinedGuardBranch(val: string | undefined): string {
  if typeof val == 'undefined' {
    return ''
  }
  return val.toUpperCase()
}

// Test 10: Type narrowing with number guard
def numberGuardBranch(val: string | number): string {
  if typeof val == 'number' {
    return val.toString()
  }
  return val.toUpperCase()
}


test('typeof narrowing with string', () => {
  expect(processString('hello')).toBe('HELLO')
  expect(processString(42)).toBe('42')
})

test('typeof narrowing with number', () => {
  expect(processNumber(21)).toBe(42)
  expect(processNumber('10')).toBe(10)
})

test('typeof narrowing with null', () => {
  expect(handleNullable('test')).toBe('TEST')
  expect(handleNullable(null)).toBe('null value')
})

test('typeof narrowing with undefined', () => {
  expect(handleOptional(5)).toBe(15)
  expect(handleOptional(undefined)).toBe(0)
})

test('typeof narrowing with boolean', () => {
  expect(handleBoolean(true)).toBe('true')
  expect(handleBoolean(false)).toBe('false')
  expect(handleBoolean('text')).toBe('text')
})

test('typeof narrowing with object', () => {
  expect(handleObject({})).toBe('is object')
  expect(handleObject('text')).toBe('text')
})

test('typeof narrowing with multiple types', () => {
  expect(handleMultiple('test')).toBe('TEST')
  expect(handleMultiple(42)).toBe('42')
  expect(handleMultiple(true)).toBe('boolean')
})

test('typeof narrowing in else branch', () => {
  expect(useElseBranch(42)).toBe('number: 42')
  expect(useElseBranch('hello')).toBe('HELLO')
})

test('type narrowing persists after early-return undefined guard', () => {
  expect(undefinedGuardBranch('hello')).toBe('HELLO')
  expect(undefinedGuardBranch(undefined)).toBe('')
})

test('type narrowing persists after early-return number guard', () => {
  expect(numberGuardBranch(42)).toBe('42')
  expect(numberGuardBranch('hello')).toBe('HELLO')
})

// ── Equality narrowing ───────────────────────────────────────────────────────

// Test 12: null equality guard — early return
def nullEqGuard(val: string | null): string {
  if val == null {
    return 'was null'
  }
  return val.toUpperCase()
}

// Test 13: null equality guard — else branch
def nullEqGuardElse(val: string | null): string {
  if val == null {
    return 'was null'
  } else {
    return val.toUpperCase()
  }
}

// Test 14: undefined equality guard — early return
def undefinedEqGuard(val: string | undefined): string {
  if val == undefined {
    return 'was undefined'
  }
  return val.toUpperCase()
}

// Test 15: undefined equality guard — else branch
def undefinedEqGuardElse(val: string | undefined): string {
  if val == undefined {
    return 'was undefined'
  } else {
    return val.toUpperCase()
  }
}

// Test 16: null guard narrows in the if-branch too (val is null inside)
def nullBranchAccess(val: string | null): string {
  if val == null {
    return 'null'
  }
  return val.toUpperCase()
}

// Test 17: null guard narrows in the if-branch too (val is null inside)
def shortIf(val: string | null): string {
  value = if val == null => 'null str' else val
  return value.toUpperCase()
}

test('equality narrowing: null guard early return', () => {
  expect(nullEqGuard('hello')).toBe('HELLO')
  expect(nullEqGuard(null)).toBe('was null')
})

test('equality narrowing: null guard else branch', () => {
  expect(nullEqGuardElse('world')).toBe('WORLD')
  expect(nullEqGuardElse(null)).toBe('was null')
})

test('equality narrowing: undefined guard early return', () => {
  expect(undefinedEqGuard('hi')).toBe('HI')
  expect(undefinedEqGuard(undefined)).toBe('was undefined')
})

test('equality narrowing: undefined guard else branch', () => {
  expect(undefinedEqGuardElse('bye')).toBe('BYE')
  expect(undefinedEqGuardElse(undefined)).toBe('was undefined')
})

test('equality narrowing: null branch access', () => {
  expect(nullBranchAccess('test')).toBe('TEST')
  expect(nullBranchAccess(null)).toBe('null')
})

// ── Equality narrowing in short-if expressions (if cond => x else y) ────────

test('equality narrowing in short-if else branch', () => {
  expect(shortIf('hello')).toBe('HELLO')
  expect(shortIf(null)).toBe('NULL STR')
})
