// This code is automatically generated by the meta parser, do not modify
// produced with metaParserGenerator.js

let best_failure;
let best_failure_array = [];
let best_failure_index = 0;

function record_failure(failure, i) {
  if (i > best_failure_index) {
    best_failure_array = [];
  }
  if (best_failure_array.length === 0) {
    best_failure = failure;
  }
  best_failure_array.push(failure);
  best_failure_index = i;
}

let cache = {};

function memoize(name, func) {
  return function memoize_inner(stream, index) {
    const key = `${name}-${index}`;
    let value = cache[key];
    if (value !== undefined) {
      return value;
    }
    value = func(stream, index);
    cache[key] = value;
    return value;
  };
}

let cacheR = {};

// based on https://medium.com/@gvanrossum_83706/left-recursive-peg-grammars-65dab3c580e1
function memoize_left_recur(name, func) {
  return function memoize_inner(stream, index) {
    const key = `${name}-${index}`;
    let value = cacheR[key];
    if (value !== undefined) {
      return value;
    }
    // prime this rule with a failure
    cacheR[key] = false;
    let lastpos;
    let lastvalue = value;
    while (true) {
      value = func(stream, index);
      if (!value) break;
      if (value.last_index <= lastpos) break;
      lastpos = value.last_index;
      lastvalue = value;
      cacheR[key] = value;
    }
    return lastvalue;
  };
}


let START_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'START',
    subRule: 0, type: 'START', named,
  };
  const _rule_0 = GLOBAL_STATEMENT(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  let _rule_1 = GLOBAL_STATEMENTS(stream, i);
  while (_rule_1) {
    children.push(_rule_1);
    i = _rule_1.last_index;
    _rule_1 = GLOBAL_STATEMENTS(stream, i);
  }

  if (stream[i].type !== 'EOS') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'START', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
START_0 = memoize('START_0', START_0);


let START_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'START',
    subRule: 1, type: 'START', named,
  };
  let _rule_0 = GLOBAL_STATEMENTS(stream, i);
  while (_rule_0) {
    children.push(_rule_0);
    i = _rule_0.last_index;
    _rule_0 = GLOBAL_STATEMENTS(stream, i);
  }

  if (stream[i].type !== 'EOS') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'START', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
START_1 = memoize('START_1', START_1);


function START(stream, index) {
  return START_0(stream, index)
    || START_1(stream, index);
}
let GLOBAL_STATEMENTS_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'GLOBAL_STATEMENTS',
    subRule: 0, type: 'GLOBAL_STATEMENTS', named,
  };

  if (stream[i].type !== 'newline') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'GLOBAL_STATEMENTS', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = GLOBAL_STATEMENT(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;
  const _rule_2 = wcomment(stream, i);
  if (_rule_2) {
    children.push(_rule_2);
    i = _rule_2.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
GLOBAL_STATEMENTS_0 = memoize('GLOBAL_STATEMENTS_0', GLOBAL_STATEMENTS_0);


let GLOBAL_STATEMENTS_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'GLOBAL_STATEMENTS',
    subRule: 1, type: 'GLOBAL_STATEMENTS', named,
  };

  if (stream[i].type !== 'newline') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'GLOBAL_STATEMENTS', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = scomment(stream, i);
  if (_rule_1) {
    children.push(_rule_1);
    i = _rule_1.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
GLOBAL_STATEMENTS_1 = memoize('GLOBAL_STATEMENTS_1', GLOBAL_STATEMENTS_1);


function GLOBAL_STATEMENTS(stream, index) {
  return GLOBAL_STATEMENTS_0(stream, index)
    || GLOBAL_STATEMENTS_1(stream, index);
}
let SCOPED_STATEMENTS_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'SCOPED_STATEMENTS',
    subRule: 0, type: 'SCOPED_STATEMENTS', named,
  };

  if (stream[i].type !== 'newline') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'SCOPED_STATEMENTS', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (stream[i].type === 'w') {
    children.push(stream[i]); i++;
  }
  if (stream[i].type === 'W') {
    children.push(stream[i]); i++;
  }
  const _rule_3 = SCOPED_STATEMENT(stream, i);
  if (!_rule_3) return false;
  children.push(_rule_3);
  i = _rule_3.last_index;
  const _rule_4 = wcomment(stream, i);
  if (_rule_4) {
    children.push(_rule_4);
    i = _rule_4.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
SCOPED_STATEMENTS_0 = memoize('SCOPED_STATEMENTS_0', SCOPED_STATEMENTS_0);


let SCOPED_STATEMENTS_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'SCOPED_STATEMENTS',
    subRule: 1, type: 'SCOPED_STATEMENTS', named,
  };

  if (stream[i].type !== 'newline') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'SCOPED_STATEMENTS', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (stream[i].type === 'w') {
    children.push(stream[i]); i++;
  }
  if (stream[i].type === 'W') {
    children.push(stream[i]); i++;
  }
  const _rule_3 = scomment(stream, i);
  if (_rule_3) {
    children.push(_rule_3);
    i = _rule_3.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
SCOPED_STATEMENTS_1 = memoize('SCOPED_STATEMENTS_1', SCOPED_STATEMENTS_1);


function SCOPED_STATEMENTS(stream, index) {
  return SCOPED_STATEMENTS_0(stream, index)
    || SCOPED_STATEMENTS_1(stream, index);
}
let wcomment_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'wcomment',
    subRule: 0, type: 'wcomment', named,
  };

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'wcomment', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'comment') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'wcomment', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
wcomment_0 = memoize('wcomment_0', wcomment_0);


let wcomment_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'wcomment',
    subRule: 1, type: 'wcomment', named,
  };

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'wcomment', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'multiline_comment') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'wcomment', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
wcomment_1 = memoize('wcomment_1', wcomment_1);


function wcomment(stream, index) {
  return wcomment_0(stream, index)
    || wcomment_1(stream, index);
}
let scomment_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'scomment',
    subRule: 0, type: 'scomment', named,
  };

  if (stream[i].type !== 'comment') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'scomment', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
scomment_0 = memoize('scomment_0', scomment_0);


let scomment_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'scomment',
    subRule: 1, type: 'scomment', named,
  };

  if (stream[i].type !== 'multiline_comment') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'scomment', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
scomment_1 = memoize('scomment_1', scomment_1);


function scomment(stream, index) {
  return scomment_0(stream, index)
    || scomment_1(stream, index);
}
let GLOBAL_STATEMENT_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'GLOBAL_STATEMENT',
    subRule: 0, type: 'GLOBAL_STATEMENT', named,
  };
  const _rule_0 = condition(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
GLOBAL_STATEMENT_0 = memoize('GLOBAL_STATEMENT_0', GLOBAL_STATEMENT_0);


let GLOBAL_STATEMENT_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'GLOBAL_STATEMENT',
    subRule: 1, type: 'GLOBAL_STATEMENT', named,
  };
  const _rule_0 = assign(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
GLOBAL_STATEMENT_1 = memoize('GLOBAL_STATEMENT_1', GLOBAL_STATEMENT_1);


let GLOBAL_STATEMENT_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'GLOBAL_STATEMENT',
    subRule: 2, type: 'GLOBAL_STATEMENT', named,
  };
  const _rule_0 = virtual_node(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
GLOBAL_STATEMENT_2 = memoize('GLOBAL_STATEMENT_2', GLOBAL_STATEMENT_2);


let GLOBAL_STATEMENT_3 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'GLOBAL_STATEMENT',
    subRule: 3, type: 'GLOBAL_STATEMENT', named,
  };
  const _rule_0 = class_def(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
GLOBAL_STATEMENT_3 = memoize('GLOBAL_STATEMENT_3', GLOBAL_STATEMENT_3);


let GLOBAL_STATEMENT_4 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'GLOBAL_STATEMENT',
    subRule: 4, type: 'GLOBAL_STATEMENT', named,
  };
  const _rule_0 = try_catch(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
GLOBAL_STATEMENT_4 = memoize('GLOBAL_STATEMENT_4', GLOBAL_STATEMENT_4);


let GLOBAL_STATEMENT_5 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'GLOBAL_STATEMENT',
    subRule: 5, type: 'GLOBAL_STATEMENT', named,
  };
  const _rule_0 = for_loop(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
GLOBAL_STATEMENT_5 = memoize('GLOBAL_STATEMENT_5', GLOBAL_STATEMENT_5);


let GLOBAL_STATEMENT_6 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'GLOBAL_STATEMENT',
    subRule: 6, type: 'GLOBAL_STATEMENT', named,
  };
  const _rule_0 = while_loop(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
GLOBAL_STATEMENT_6 = memoize('GLOBAL_STATEMENT_6', GLOBAL_STATEMENT_6);


let GLOBAL_STATEMENT_7 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'GLOBAL_STATEMENT',
    subRule: 7, type: 'GLOBAL_STATEMENT', named,
  };
  const _rule_0 = import_statement(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
GLOBAL_STATEMENT_7 = memoize('GLOBAL_STATEMENT_7', GLOBAL_STATEMENT_7);


let GLOBAL_STATEMENT_8 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'GLOBAL_STATEMENT',
    subRule: 8, type: 'GLOBAL_STATEMENT', named,
  };
  const _rule_0 = exp_statement(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
GLOBAL_STATEMENT_8 = memoize('GLOBAL_STATEMENT_8', GLOBAL_STATEMENT_8);


function GLOBAL_STATEMENT(stream, index) {
  return GLOBAL_STATEMENT_0(stream, index)
    || GLOBAL_STATEMENT_1(stream, index)
    || GLOBAL_STATEMENT_2(stream, index)
    || GLOBAL_STATEMENT_3(stream, index)
    || GLOBAL_STATEMENT_4(stream, index)
    || GLOBAL_STATEMENT_5(stream, index)
    || GLOBAL_STATEMENT_6(stream, index)
    || GLOBAL_STATEMENT_7(stream, index)
    || GLOBAL_STATEMENT_8(stream, index);
}
let exp_statement_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp_statement',
    subRule: 0, type: 'exp_statement', named,
  };
  const _rule_0 = exp(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_statement_0 = memoize('exp_statement_0', exp_statement_0);


function exp_statement(stream, index) {
  return exp_statement_0(stream, index);
}
let SCOPED_STATEMENT_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'SCOPED_STATEMENT',
    subRule: 0, type: 'SCOPED_STATEMENT', named,
  };
  const _rule_0 = condition(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
SCOPED_STATEMENT_0 = memoize('SCOPED_STATEMENT_0', SCOPED_STATEMENT_0);


let SCOPED_STATEMENT_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'SCOPED_STATEMENT',
    subRule: 1, type: 'SCOPED_STATEMENT', named,
  };
  const _rule_0 = assign(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
SCOPED_STATEMENT_1 = memoize('SCOPED_STATEMENT_1', SCOPED_STATEMENT_1);


let SCOPED_STATEMENT_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'SCOPED_STATEMENT',
    subRule: 2, type: 'SCOPED_STATEMENT', named,
  };
  const _rule_0 = virtual_node(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
SCOPED_STATEMENT_2 = memoize('SCOPED_STATEMENT_2', SCOPED_STATEMENT_2);


let SCOPED_STATEMENT_3 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'SCOPED_STATEMENT',
    subRule: 3, type: 'SCOPED_STATEMENT', named,
  };
  const _rule_0 = try_catch(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
SCOPED_STATEMENT_3 = memoize('SCOPED_STATEMENT_3', SCOPED_STATEMENT_3);


let SCOPED_STATEMENT_4 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'SCOPED_STATEMENT',
    subRule: 4, type: 'SCOPED_STATEMENT', named,
  };
  const _rule_0 = for_loop(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
SCOPED_STATEMENT_4 = memoize('SCOPED_STATEMENT_4', SCOPED_STATEMENT_4);


let SCOPED_STATEMENT_5 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'SCOPED_STATEMENT',
    subRule: 5, type: 'SCOPED_STATEMENT', named,
  };
  const _rule_0 = while_loop(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
SCOPED_STATEMENT_5 = memoize('SCOPED_STATEMENT_5', SCOPED_STATEMENT_5);


let SCOPED_STATEMENT_6 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'SCOPED_STATEMENT',
    subRule: 6, type: 'SCOPED_STATEMENT', named,
  };

  if (stream[i].type !== 'return') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'SCOPED_STATEMENT', sub_rule_index: 6,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (_rule_1) {
    children.push(_rule_1);
    i = _rule_1.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
SCOPED_STATEMENT_6 = memoize('SCOPED_STATEMENT_6', SCOPED_STATEMENT_6);


let SCOPED_STATEMENT_7 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'SCOPED_STATEMENT',
    subRule: 7, type: 'SCOPED_STATEMENT', named,
  };
  const _rule_0 = exp_statement(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
SCOPED_STATEMENT_7 = memoize('SCOPED_STATEMENT_7', SCOPED_STATEMENT_7);


let SCOPED_STATEMENT_8 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'SCOPED_STATEMENT',
    subRule: 8, type: 'SCOPED_STATEMENT', named,
  };

  if (stream[i].type !== 'break') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'SCOPED_STATEMENT', sub_rule_index: 8,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
SCOPED_STATEMENT_8 = memoize('SCOPED_STATEMENT_8', SCOPED_STATEMENT_8);


let SCOPED_STATEMENT_9 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'SCOPED_STATEMENT',
    subRule: 9, type: 'SCOPED_STATEMENT', named,
  };

  if (stream[i].type !== 'continue') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'SCOPED_STATEMENT', sub_rule_index: 9,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
SCOPED_STATEMENT_9 = memoize('SCOPED_STATEMENT_9', SCOPED_STATEMENT_9);


function SCOPED_STATEMENT(stream, index) {
  return SCOPED_STATEMENT_0(stream, index)
    || SCOPED_STATEMENT_1(stream, index)
    || SCOPED_STATEMENT_2(stream, index)
    || SCOPED_STATEMENT_3(stream, index)
    || SCOPED_STATEMENT_4(stream, index)
    || SCOPED_STATEMENT_5(stream, index)
    || SCOPED_STATEMENT_6(stream, index)
    || SCOPED_STATEMENT_7(stream, index)
    || SCOPED_STATEMENT_8(stream, index)
    || SCOPED_STATEMENT_9(stream, index);
}
let object_access_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'object_access',
    subRule: 0, type: 'object_access', named,
  };

  if (stream[i].type !== '.') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_access', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_access', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = object_access(stream, i);
  if (_rule_2) {
    children.push(_rule_2);
    i = _rule_2.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
object_access_0 = memoize('object_access_0', object_access_0);


let object_access_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'object_access',
    subRule: 1, type: 'object_access', named,
  };
  const _rule_0 = func_call(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  const _rule_1 = object_access(stream, i);
  if (_rule_1) {
    children.push(_rule_1);
    i = _rule_1.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
object_access_1 = memoize('object_access_1', object_access_1);


let object_access_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'object_access',
    subRule: 2, type: 'object_access', named,
  };

  if (stream[i].type !== '[') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_access', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;

  if (stream[i].type !== ']') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_access', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_3 = object_access(stream, i);
  if (_rule_3) {
    children.push(_rule_3);
    i = _rule_3.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
object_access_2 = memoize('object_access_2', object_access_2);


function object_access(stream, index) {
  return object_access_0(stream, index)
    || object_access_1(stream, index)
    || object_access_2(stream, index);
}
let assign_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'assign',
    subRule: 0, type: 'assign', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_1 = annotation(stream, i);
  if (_rule_1) {
    children.push(_rule_1);
    named['annotation'] = _rule_1;
    i = _rule_1.last_index;
  }

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'explicit_assign') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['explicit_assign'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_5 = exp(stream, i);
  if (!_rule_5) return false;
  named['exp'] = _rule_5;
  children.push(_rule_5);
  i = _rule_5.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
assign_0 = memoize('assign_0', assign_0);


let assign_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'assign',
    subRule: 1, type: 'assign', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_1 = annotation(stream, i);
  if (_rule_1) {
    children.push(_rule_1);
    named['annotation'] = _rule_1;
    i = _rule_1.last_index;
  }

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '=') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_5 = exp(stream, i);
  if (!_rule_5) return false;
  named['exp'] = _rule_5;
  children.push(_rule_5);
  i = _rule_5.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
assign_1 = memoize('assign_1', assign_1);


let assign_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'assign',
    subRule: 2, type: 'assign', named,
  };
  const _rule_0 = object_destructuring(stream, i);
  if (!_rule_0) return false;
  named['destructuring'] = _rule_0;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '=') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_4 = exp(stream, i);
  if (!_rule_4) return false;
  named['exp'] = _rule_4;
  children.push(_rule_4);
  i = _rule_4.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
assign_2 = memoize('assign_2', assign_2);


let assign_3 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'assign',
    subRule: 3, type: 'assign', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['path'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_1 = object_access(stream, i);
  if (!_rule_1) return false;
  named['access'] = _rule_1;
  children.push(_rule_1);
  i = _rule_1.last_index;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '=') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'assign', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_5 = exp(stream, i);
  if (!_rule_5) return false;
  named['exp'] = _rule_5;
  children.push(_rule_5);
  i = _rule_5.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
assign_3 = memoize('assign_3', assign_3);


function assign(stream, index) {
  return assign_0(stream, index)
    || assign_1(stream, index)
    || assign_2(stream, index)
    || assign_3(stream, index);
}
let for_loop_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'for_loop',
    subRule: 0, type: 'for_loop', named,
  };

  if (stream[i].type !== 'for') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['value'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'in') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_4 = exp(stream, i);
  if (!_rule_4) return false;
  named['exp'] = _rule_4;
  children.push(_rule_4);
  i = _rule_4.last_index;
  const _rule_5 = annotation(stream, i);
  if (_rule_5) {
    children.push(_rule_5);
    named['objectannotation'] = _rule_5;
    i = _rule_5.last_index;
  }

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 7,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_8 = SCOPED_STATEMENTS(stream, i);
  while (_rule_8) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_8);
    children.push(_rule_8);
    i = _rule_8.last_index;
    _rule_8 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 9,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
for_loop_0 = memoize('for_loop_0', for_loop_0);


let for_loop_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'for_loop',
    subRule: 1, type: 'for_loop', named,
  };

  if (stream[i].type !== 'for') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['key'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_2 = annotation(stream, i);
  if (_rule_2) {
    children.push(_rule_2);
    named['keyannotation'] = _rule_2;
    i = _rule_2.last_index;
  }

  if (stream[i].type !== ',') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['value'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'in') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 7,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_8 = exp(stream, i);
  if (!_rule_8) return false;
  named['exp'] = _rule_8;
  children.push(_rule_8);
  i = _rule_8.last_index;
  const _rule_9 = annotation(stream, i);
  if (_rule_9) {
    children.push(_rule_9);
    named['objectannotation'] = _rule_9;
    i = _rule_9.last_index;
  }

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 10,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 11,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_12 = SCOPED_STATEMENTS(stream, i);
  while (_rule_12) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_12);
    children.push(_rule_12);
    i = _rule_12.last_index;
    _rule_12 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'for_loop', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 13,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
for_loop_1 = memoize('for_loop_1', for_loop_1);


function for_loop(stream, index) {
  return for_loop_0(stream, index)
    || for_loop_1(stream, index);
}
let func_def_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_def',
    subRule: 0, type: 'func_def', named,
  };
  if (stream[i].type === 'async') {
    named['async'] = stream[i];
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== 'def') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (stream[i].type === 'name') {
    named['name'] = stream[i];
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== '(') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== ')') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_5 = annotation(stream, i);
  if (_rule_5) {
    children.push(_rule_5);
    named['annotation'] = _rule_5;
    i = _rule_5.last_index;
  }

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_7 = func_body(stream, i);
  if (!_rule_7) return false;
  named['body'] = _rule_7;
  children.push(_rule_7);
  i = _rule_7.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_def_0 = memoize('func_def_0', func_def_0);


let func_def_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_def',
    subRule: 1, type: 'func_def', named,
  };
  if (stream[i].type === 'async') {
    named['async'] = stream[i];
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== 'def') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (stream[i].type === 'name') {
    named['name'] = stream[i];
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== '(') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_4 = func_def_params(stream, i);
  if (!_rule_4) return false;
  named['params'] = _rule_4;
  children.push(_rule_4);
  i = _rule_4.last_index;

  if (stream[i].type !== ')') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_6 = annotation(stream, i);
  if (_rule_6) {
    children.push(_rule_6);
    named['annotation'] = _rule_6;
    i = _rule_6.last_index;
  }

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 7,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_8 = func_body(stream, i);
  if (!_rule_8) return false;
  named['body'] = _rule_8;
  children.push(_rule_8);
  i = _rule_8.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_def_1 = memoize('func_def_1', func_def_1);


let func_def_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_def',
    subRule: 2, type: 'func_def', named,
  };
  if (stream[i].type === 'async') {
    named['async'] = stream[i];
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== '(') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = func_def_params(stream, i);
  if (!_rule_2) return false;
  named['params'] = _rule_2;
  children.push(_rule_2);
  i = _rule_2.last_index;

  if (stream[i].type !== ')') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_4 = annotation(stream, i);
  if (_rule_4) {
    children.push(_rule_4);
    named['annotation'] = _rule_4;
    i = _rule_4.last_index;
  }

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '=>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['fat-arrow'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 7,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_8 = func_body_fat(stream, i);
  if (!_rule_8) return false;
  named['body'] = _rule_8;
  children.push(_rule_8);
  i = _rule_8.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_def_2 = memoize('func_def_2', func_def_2);


let func_def_3 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_def',
    subRule: 3, type: 'func_def', named,
  };
  if (stream[i].type === 'async') {
    named['async'] = stream[i];
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== '(') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== ')') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_3 = annotation(stream, i);
  if (_rule_3) {
    children.push(_rule_3);
    named['annotation'] = _rule_3;
    i = _rule_3.last_index;
  }

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '=>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['fat-arrow'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_7 = func_body_fat(stream, i);
  if (!_rule_7) return false;
  named['body'] = _rule_7;
  children.push(_rule_7);
  i = _rule_7.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_def_3 = memoize('func_def_3', func_def_3);


function func_def(stream, index) {
  return func_def_0(stream, index)
    || func_def_1(stream, index)
    || func_def_2(stream, index)
    || func_def_3(stream, index);
}
let annotation_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'annotation',
    subRule: 0, type: 'annotation', named,
  };

  if (stream[i].type !== 'colon') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'annotation', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'annotation', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'annotation', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
annotation_0 = memoize('annotation_0', annotation_0);


function annotation(stream, index) {
  return annotation_0(stream, index);
}
let func_def_params_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_def_params',
    subRule: 0, type: 'func_def_params', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def_params', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== '=') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def_params', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = exp(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;
  const _rule_3 = annotation(stream, i);
  if (_rule_3) {
    children.push(_rule_3);
    named['annotation'] = _rule_3;
    i = _rule_3.last_index;
  }

  if (stream[i].type !== ',') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def_params', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def_params', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_6 = func_def_params(stream, i);
  if (!_rule_6) return false;
  children.push(_rule_6);
  i = _rule_6.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_def_params_0 = memoize('func_def_params_0', func_def_params_0);


let func_def_params_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_def_params',
    subRule: 1, type: 'func_def_params', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def_params', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== '=') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def_params', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = exp(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;
  const _rule_3 = annotation(stream, i);
  if (_rule_3) {
    children.push(_rule_3);
    named['annotation'] = _rule_3;
    i = _rule_3.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_def_params_1 = memoize('func_def_params_1', func_def_params_1);


let func_def_params_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_def_params',
    subRule: 2, type: 'func_def_params', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def_params', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_1 = annotation(stream, i);
  if (_rule_1) {
    children.push(_rule_1);
    named['annotation'] = _rule_1;
    i = _rule_1.last_index;
  }

  if (stream[i].type !== ',') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def_params', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def_params', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_4 = func_def_params(stream, i);
  if (!_rule_4) return false;
  children.push(_rule_4);
  i = _rule_4.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_def_params_2 = memoize('func_def_params_2', func_def_params_2);


let func_def_params_3 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_def_params',
    subRule: 3, type: 'func_def_params', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_def_params', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_1 = annotation(stream, i);
  if (_rule_1) {
    children.push(_rule_1);
    named['annotation'] = _rule_1;
    i = _rule_1.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_def_params_3 = memoize('func_def_params_3', func_def_params_3);


function func_def_params(stream, index) {
  return func_def_params_0(stream, index)
    || func_def_params_1(stream, index)
    || func_def_params_2(stream, index)
    || func_def_params_3(stream, index);
}
let func_call_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_call',
    subRule: 0, type: 'func_call', named,
  };

  if (stream[i].type !== '(') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_call', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = newline_and_space(stream, i);
  if (_rule_1) {
    children.push(_rule_1);
    i = _rule_1.last_index;
  }
  const _rule_2 = func_call_params(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;

  if (stream[i].type !== ')') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_call', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_call_0 = memoize('func_call_0', func_call_0);


let func_call_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_call',
    subRule: 1, type: 'func_call', named,
  };

  if (stream[i].type !== '(') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_call', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== ')') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_call', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_call_1 = memoize('func_call_1', func_call_1);


function func_call(stream, index) {
  return func_call_0(stream, index)
    || func_call_1(stream, index);
}
let named_func_call_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'named_func_call',
    subRule: 0, type: 'named_func_call', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'named_func_call', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_1 = func_call(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
named_func_call_0 = memoize('named_func_call_0', named_func_call_0);


function named_func_call(stream, index) {
  return named_func_call_0(stream, index);
}
let func_call_params_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_call_params',
    subRule: 0, type: 'func_call_params', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_call_params', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '=') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_call_params', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = exp(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_call_params_0 = memoize('func_call_params_0', func_call_params_0);


let func_call_params_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_call_params',
    subRule: 1, type: 'func_call_params', named,
  };
  const _rule_0 = exp(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== ',') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_call_params', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = single_space_or_newline(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;
  const _rule_3 = func_call_params(stream, i);
  if (!_rule_3) return false;
  children.push(_rule_3);
  i = _rule_3.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_call_params_1 = memoize('func_call_params_1', func_call_params_1);


let func_call_params_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_call_params',
    subRule: 2, type: 'func_call_params', named,
  };
  const _rule_0 = exp(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_call_params_2 = memoize('func_call_params_2', func_call_params_2);


function func_call_params(stream, index) {
  return func_call_params_0(stream, index)
    || func_call_params_1(stream, index)
    || func_call_params_2(stream, index);
}
let func_body_fat_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_body_fat',
    subRule: 0, type: 'func_body_fat', named,
  };

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_body_fat', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_1 = SCOPED_STATEMENTS(stream, i);
  while (_rule_1) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_1);
    children.push(_rule_1);
    i = _rule_1.last_index;
    _rule_1 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_body_fat', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_body_fat_0 = memoize('func_body_fat_0', func_body_fat_0);


let func_body_fat_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_body_fat',
    subRule: 1, type: 'func_body_fat', named,
  };
  const _rule_0 = exp(stream, i);
  if (!_rule_0) return false;
  named['exp'] = _rule_0;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_body_fat_1 = memoize('func_body_fat_1', func_body_fat_1);


function func_body_fat(stream, index) {
  return func_body_fat_0(stream, index)
    || func_body_fat_1(stream, index);
}
let func_body_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'func_body',
    subRule: 0, type: 'func_body', named,
  };

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_body', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_1 = SCOPED_STATEMENTS(stream, i);
  while (_rule_1) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_1);
    children.push(_rule_1);
    i = _rule_1.last_index;
    _rule_1 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'func_body', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
func_body_0 = memoize('func_body_0', func_body_0);


function func_body(stream, index) {
  return func_body_0(stream, index);
}
let class_def_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'class_def',
    subRule: 0, type: 'class_def', named,
  };

  if (stream[i].type !== 'clazz') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'extends') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['extends'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_7 = CLASS_STATEMENT(stream, i);
  while (_rule_7) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_7);
    children.push(_rule_7);
    i = _rule_7.last_index;
    _rule_7 = CLASS_STATEMENT(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 8,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
class_def_0 = memoize('class_def_0', class_def_0);


let class_def_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'class_def',
    subRule: 1, type: 'class_def', named,
  };

  if (stream[i].type !== 'clazz') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_4 = CLASS_STATEMENT(stream, i);
  while (_rule_4) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_4);
    children.push(_rule_4);
    i = _rule_4.last_index;
    _rule_4 = CLASS_STATEMENT(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
class_def_1 = memoize('class_def_1', class_def_1);


function class_def(stream, index) {
  return class_def_0(stream, index)
    || class_def_1(stream, index);
}
let class_func_def_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'class_func_def',
    subRule: 0, type: 'class_func_def', named,
  };
  if (stream[i].type === 'async') {
    named['async'] = stream[i];
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== 'def') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_func_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (stream[i].type === 'name') {
    named['name'] = stream[i];
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== '(') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_func_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== ')') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_func_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_5 = annotation(stream, i);
  if (_rule_5) {
    children.push(_rule_5);
    i = _rule_5.last_index;
  }

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_func_def', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_7 = func_body(stream, i);
  if (!_rule_7) return false;
  named['body'] = _rule_7;
  children.push(_rule_7);
  i = _rule_7.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
class_func_def_0 = memoize('class_func_def_0', class_func_def_0);


let class_func_def_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'class_func_def',
    subRule: 1, type: 'class_func_def', named,
  };
  if (stream[i].type === 'async') {
    named['async'] = stream[i];
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== 'def') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_func_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (stream[i].type === 'name') {
    named['name'] = stream[i];
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== '(') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_func_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_4 = func_def_params(stream, i);
  if (!_rule_4) return false;
  named['params'] = _rule_4;
  children.push(_rule_4);
  i = _rule_4.last_index;

  if (stream[i].type !== ')') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_func_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_6 = annotation(stream, i);
  if (_rule_6) {
    children.push(_rule_6);
    i = _rule_6.last_index;
  }

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'class_func_def', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 7,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_8 = func_body(stream, i);
  if (!_rule_8) return false;
  named['body'] = _rule_8;
  children.push(_rule_8);
  i = _rule_8.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
class_func_def_1 = memoize('class_func_def_1', class_func_def_1);


function class_func_def(stream, index) {
  return class_func_def_0(stream, index)
    || class_func_def_1(stream, index);
}
let CLASS_STATEMENT_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'CLASS_STATEMENT',
    subRule: 0, type: 'CLASS_STATEMENT', named,
  };

  if (stream[i].type !== 'newline') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'CLASS_STATEMENT', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (stream[i].type === 'w') {
    children.push(stream[i]); i++;
  }
  if (stream[i].type === 'W') {
    children.push(stream[i]); i++;
  }
  const _rule_3 = class_func_def(stream, i);
  if (!_rule_3) return false;
  children.push(_rule_3);
  i = _rule_3.last_index;
  const _rule_4 = wcomment(stream, i);
  if (_rule_4) {
    children.push(_rule_4);
    i = _rule_4.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
CLASS_STATEMENT_0 = memoize('CLASS_STATEMENT_0', CLASS_STATEMENT_0);


let CLASS_STATEMENT_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'CLASS_STATEMENT',
    subRule: 1, type: 'CLASS_STATEMENT', named,
  };

  if (stream[i].type !== 'newline') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'CLASS_STATEMENT', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (stream[i].type === 'w') {
    children.push(stream[i]); i++;
  }
  if (stream[i].type === 'W') {
    children.push(stream[i]); i++;
  }
  const _rule_3 = scomment(stream, i);
  if (_rule_3) {
    children.push(_rule_3);
    i = _rule_3.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
CLASS_STATEMENT_1 = memoize('CLASS_STATEMENT_1', CLASS_STATEMENT_1);


function CLASS_STATEMENT(stream, index) {
  return CLASS_STATEMENT_0(stream, index)
    || CLASS_STATEMENT_1(stream, index);
}
let array_literal_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'array_literal',
    subRule: 0, type: 'array_literal', named,
  };

  if (stream[i].type !== '[') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'array_literal', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (stream[i].type === 'newline') {
    children.push(stream[i]); i++;
  }
  if (stream[i].type === 'W') {
    children.push(stream[i]); i++;
  }
  const _rule_3 = array_literal_body(stream, i);
  if (!_rule_3) return false;
  children.push(_rule_3);
  i = _rule_3.last_index;
  if (stream[i].type === 'newline') {
    children.push(stream[i]); i++;
  }
  if (stream[i].type === 'W') {
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== ']') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'array_literal', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
array_literal_0 = memoize('array_literal_0', array_literal_0);


let array_literal_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'array_literal',
    subRule: 1, type: 'array_literal', named,
  };

  if (stream[i].type !== '[') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'array_literal', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== ']') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'array_literal', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
array_literal_1 = memoize('array_literal_1', array_literal_1);


function array_literal(stream, index) {
  return array_literal_0(stream, index)
    || array_literal_1(stream, index);
}
let array_literal_body_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'array_literal_body',
    subRule: 0, type: 'array_literal_body', named,
  };
  const _rule_0 = exp(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== ',') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'array_literal_body', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = single_space_or_newline(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;
  const _rule_3 = array_literal_body(stream, i);
  if (!_rule_3) return false;
  children.push(_rule_3);
  i = _rule_3.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
array_literal_body_0 = memoize('array_literal_body_0', array_literal_body_0);


let array_literal_body_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'array_literal_body',
    subRule: 1, type: 'array_literal_body', named,
  };
  const _rule_0 = exp(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
array_literal_body_1 = memoize('array_literal_body_1', array_literal_body_1);


function array_literal_body(stream, index) {
  return array_literal_body_0(stream, index)
    || array_literal_body_1(stream, index);
}
let condition_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'condition',
    subRule: 0, type: 'condition', named,
  };

  if (stream[i].type !== 'if') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'condition', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['type'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (!_rule_1) return false;
  named['exp'] = _rule_1;
  children.push(_rule_1);
  i = _rule_1.last_index;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'condition', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'condition', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_4 = SCOPED_STATEMENTS(stream, i);
  while (_rule_4) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_4);
    children.push(_rule_4);
    i = _rule_4.last_index;
    _rule_4 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'condition', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_6 = else_if(stream, i);
  if (_rule_6) {
    children.push(_rule_6);
    named['elseif'] = _rule_6;
    i = _rule_6.last_index;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
condition_0 = memoize('condition_0', condition_0);


function condition(stream, index) {
  return condition_0(stream, index);
}
let else_if_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'else_if',
    subRule: 0, type: 'else_if', named,
  };

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'elseif') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['type'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_2 = exp(stream, i);
  if (!_rule_2) return false;
  named['exp'] = _rule_2;
  children.push(_rule_2);
  i = _rule_2.last_index;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_5 = SCOPED_STATEMENTS(stream, i);
  while (_rule_5) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_5);
    children.push(_rule_5);
    i = _rule_5.last_index;
    _rule_5 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_7 = else_if(stream, i);
  if (!_rule_7) return false;
  named['elseif'] = _rule_7;
  children.push(_rule_7);
  i = _rule_7.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
else_if_0 = memoize('else_if_0', else_if_0);


let else_if_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'else_if',
    subRule: 1, type: 'else_if', named,
  };

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'elseif') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['type'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_2 = exp(stream, i);
  if (!_rule_2) return false;
  named['exp'] = _rule_2;
  children.push(_rule_2);
  i = _rule_2.last_index;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_5 = SCOPED_STATEMENTS(stream, i);
  while (_rule_5) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_5);
    children.push(_rule_5);
    i = _rule_5.last_index;
    _rule_5 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
else_if_1 = memoize('else_if_1', else_if_1);


let else_if_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'else_if',
    subRule: 2, type: 'else_if', named,
  };

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'else') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['type'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_3 = SCOPED_STATEMENTS(stream, i);
  while (_rule_3) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_3);
    children.push(_rule_3);
    i = _rule_3.last_index;
    _rule_3 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'else_if', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
else_if_2 = memoize('else_if_2', else_if_2);


let else_if_3 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'else_if',
    subRule: 3, type: 'else_if', named,
  };
  if (stream[i].type === 'w') {
    children.push(stream[i]); i++;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
else_if_3 = memoize('else_if_3', else_if_3);


function else_if(stream, index) {
  return else_if_0(stream, index)
    || else_if_1(stream, index)
    || else_if_2(stream, index)
    || else_if_3(stream, index);
}
let while_loop_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'while_loop',
    subRule: 0, type: 'while_loop', named,
  };

  if (stream[i].type !== 'while') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'while_loop', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (!_rule_1) return false;
  named['exp'] = _rule_1;
  children.push(_rule_1);
  i = _rule_1.last_index;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'while_loop', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'while_loop', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_4 = SCOPED_STATEMENTS(stream, i);
  while (_rule_4) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_4);
    children.push(_rule_4);
    i = _rule_4.last_index;
    _rule_4 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'while_loop', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
while_loop_0 = memoize('while_loop_0', while_loop_0);


function while_loop(stream, index) {
  return while_loop_0(stream, index);
}
let object_literal_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'object_literal',
    subRule: 0, type: 'object_literal', named,
  };

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_literal', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = single_space_or_newline(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;
  const _rule_2 = object_literal_body(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;
  const _rule_3 = single_space_or_newline(stream, i);
  if (!_rule_3) return false;
  children.push(_rule_3);
  i = _rule_3.last_index;

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_literal', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
object_literal_0 = memoize('object_literal_0', object_literal_0);


let object_literal_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'object_literal',
    subRule: 1, type: 'object_literal', named,
  };

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_literal', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_literal', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
object_literal_1 = memoize('object_literal_1', object_literal_1);


function object_literal(stream, index) {
  return object_literal_0(stream, index)
    || object_literal_1(stream, index);
}
let single_space_or_newline_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'single_space_or_newline',
    subRule: 0, type: 'single_space_or_newline', named,
  };

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'single_space_or_newline', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
single_space_or_newline_0 = memoize('single_space_or_newline_0', single_space_or_newline_0);


let single_space_or_newline_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'single_space_or_newline',
    subRule: 1, type: 'single_space_or_newline', named,
  };

  if (stream[i].type !== 'newline') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'single_space_or_newline', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (stream[i].type === 'w') {
    children.push(stream[i]); i++;
  }
  if (stream[i].type === 'W') {
    children.push(stream[i]); i++;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
single_space_or_newline_1 = memoize('single_space_or_newline_1', single_space_or_newline_1);


function single_space_or_newline(stream, index) {
  return single_space_or_newline_0(stream, index)
    || single_space_or_newline_1(stream, index);
}
let newline_and_space_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'newline_and_space',
    subRule: 0, type: 'newline_and_space', named,
  };

  if (stream[i].type !== 'newline') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'newline_and_space', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (stream[i].type === 'w') {
    children.push(stream[i]); i++;
  }
  if (stream[i].type === 'W') {
    children.push(stream[i]); i++;
  }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
newline_and_space_0 = memoize('newline_and_space_0', newline_and_space_0);


function newline_and_space(stream, index) {
  return newline_and_space_0(stream, index);
}
let object_literal_body_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'object_literal_body',
    subRule: 0, type: 'object_literal_body', named,
  };
  const _rule_0 = object_literal_key(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== 'colon') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_literal_body', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_literal_body', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_3 = exp(stream, i);
  if (!_rule_3) return false;
  children.push(_rule_3);
  i = _rule_3.last_index;

  if (stream[i].type !== ',') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_literal_body', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_5 = single_space_or_newline(stream, i);
  if (!_rule_5) return false;
  children.push(_rule_5);
  i = _rule_5.last_index;
  const _rule_6 = object_literal_body(stream, i);
  if (!_rule_6) return false;
  children.push(_rule_6);
  i = _rule_6.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
object_literal_body_0 = memoize('object_literal_body_0', object_literal_body_0);


let object_literal_body_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'object_literal_body',
    subRule: 1, type: 'object_literal_body', named,
  };
  const _rule_0 = object_literal_key(stream, i);
  if (!_rule_0) return false;
  named['key'] = _rule_0;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== ',') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_literal_body', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = single_space_or_newline(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;
  const _rule_3 = object_literal_body(stream, i);
  if (!_rule_3) return false;
  children.push(_rule_3);
  i = _rule_3.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
object_literal_body_1 = memoize('object_literal_body_1', object_literal_body_1);


let object_literal_body_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'object_literal_body',
    subRule: 2, type: 'object_literal_body', named,
  };
  const _rule_0 = object_literal_key(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== 'colon') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_literal_body', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_literal_body', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_3 = exp(stream, i);
  if (!_rule_3) return false;
  children.push(_rule_3);
  i = _rule_3.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
object_literal_body_2 = memoize('object_literal_body_2', object_literal_body_2);


let object_literal_body_3 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'object_literal_body',
    subRule: 3, type: 'object_literal_body', named,
  };
  const _rule_0 = object_literal_key(stream, i);
  if (!_rule_0) return false;
  named['key'] = _rule_0;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
object_literal_body_3 = memoize('object_literal_body_3', object_literal_body_3);


function object_literal_body(stream, index) {
  return object_literal_body_0(stream, index)
    || object_literal_body_1(stream, index)
    || object_literal_body_2(stream, index)
    || object_literal_body_3(stream, index);
}
let object_destructuring_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'object_destructuring',
    subRule: 0, type: 'object_destructuring', named,
  };

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_destructuring', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_destructuring', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = destructuring_values(stream, i);
  if (!_rule_2) return false;
  named['values'] = _rule_2;
  children.push(_rule_2);
  i = _rule_2.last_index;
  const _rule_3 = single_space_or_newline(stream, i);
  if (!_rule_3) return false;
  children.push(_rule_3);
  i = _rule_3.last_index;

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_destructuring', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
object_destructuring_0 = memoize('object_destructuring_0', object_destructuring_0);


function object_destructuring(stream, index) {
  return object_destructuring_0(stream, index);
}
let destructuring_values_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'destructuring_values',
    subRule: 0, type: 'destructuring_values', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'destructuring_values', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== ',') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'destructuring_values', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = single_space_or_newline(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;
  const _rule_3 = destructuring_values(stream, i);
  if (!_rule_3) return false;
  named['more'] = _rule_3;
  children.push(_rule_3);
  i = _rule_3.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
destructuring_values_0 = memoize('destructuring_values_0', destructuring_values_0);


let destructuring_values_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'destructuring_values',
    subRule: 1, type: 'destructuring_values', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'destructuring_values', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'destructuring_values', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'as') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'destructuring_values', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'destructuring_values', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['rename'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== ',') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'destructuring_values', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_5 = single_space_or_newline(stream, i);
  if (!_rule_5) return false;
  children.push(_rule_5);
  i = _rule_5.last_index;
  const _rule_6 = destructuring_values(stream, i);
  if (!_rule_6) return false;
  named['more'] = _rule_6;
  children.push(_rule_6);
  i = _rule_6.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
destructuring_values_1 = memoize('destructuring_values_1', destructuring_values_1);


let destructuring_values_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'destructuring_values',
    subRule: 2, type: 'destructuring_values', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'destructuring_values', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'destructuring_values', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'as') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'destructuring_values', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'destructuring_values', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['rename'] = stream[i];
  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
destructuring_values_2 = memoize('destructuring_values_2', destructuring_values_2);


let destructuring_values_3 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'destructuring_values',
    subRule: 3, type: 'destructuring_values', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'destructuring_values', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
destructuring_values_3 = memoize('destructuring_values_3', destructuring_values_3);


function destructuring_values(stream, index) {
  return destructuring_values_0(stream, index)
    || destructuring_values_1(stream, index)
    || destructuring_values_2(stream, index)
    || destructuring_values_3(stream, index);
}
let import_statement_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'import_statement',
    subRule: 0, type: 'import_statement', named,
  };

  if (stream[i].type !== 'import') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'from') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'str') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['file'] = stream[i];
  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
import_statement_0 = memoize('import_statement_0', import_statement_0);


let import_statement_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'import_statement',
    subRule: 1, type: 'import_statement', named,
  };

  if (stream[i].type !== 'import') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_3 = destructuring_values(stream, i);
  if (!_rule_3) return false;
  named['dest_values'] = _rule_3;
  children.push(_rule_3);
  i = _rule_3.last_index;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'from') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 7,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'str') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 8,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['file'] = stream[i];
  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
import_statement_1 = memoize('import_statement_1', import_statement_1);


let import_statement_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'import_statement',
    subRule: 2, type: 'import_statement', named,
  };

  if (stream[i].type !== 'import') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'str') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['module'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'as') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
import_statement_2 = memoize('import_statement_2', import_statement_2);


let import_statement_3 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'import_statement',
    subRule: 3, type: 'import_statement', named,
  };

  if (stream[i].type !== 'import') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'str') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'import_statement', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['file'] = stream[i];
  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
import_statement_3 = memoize('import_statement_3', import_statement_3);


function import_statement(stream, index) {
  return import_statement_0(stream, index)
    || import_statement_1(stream, index)
    || import_statement_2(stream, index)
    || import_statement_3(stream, index);
}
let object_literal_key_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'object_literal_key',
    subRule: 0, type: 'object_literal_key', named,
  };

  if (stream[i].type !== 'str') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_literal_key', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
object_literal_key_0 = memoize('object_literal_key_0', object_literal_key_0);


let object_literal_key_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'object_literal_key',
    subRule: 1, type: 'object_literal_key', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'object_literal_key', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
object_literal_key_1 = memoize('object_literal_key_1', object_literal_key_1);


function object_literal_key(stream, index) {
  return object_literal_key_0(stream, index)
    || object_literal_key_1(stream, index);
}
let virtual_node_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'virtual_node',
    subRule: 0, type: 'virtual_node', named,
  };

  if (stream[i].type !== '<') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['opening'] = stream[i];
  children.push(stream[i]); i++;
  let _rule_2 = virtual_node_attributes(stream, i);
  while (_rule_2) {
    named['attrs'] ? null : named['attrs'] = [];
    named['attrs'].push(_rule_2);
    children.push(_rule_2);
    i = _rule_2.last_index;
    _rule_2 = virtual_node_attributes(stream, i);
  }
  if (stream[i].type === 'w') {
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== '/>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
virtual_node_0 = memoize('virtual_node_0', virtual_node_0);


let virtual_node_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'virtual_node',
    subRule: 1, type: 'virtual_node', named,
  };

  if (stream[i].type !== '<') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['opening'] = stream[i];
  children.push(stream[i]); i++;
  let _rule_2 = virtual_node_attributes(stream, i);
  while (_rule_2) {
    named['attrs'] ? null : named['attrs'] = [];
    named['attrs'].push(_rule_2);
    children.push(_rule_2);
    i = _rule_2.last_index;
    _rule_2 = virtual_node_attributes(stream, i);
  }

  if (stream[i].type !== '>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_4 = SCOPED_STATEMENTS(stream, i);
  while (_rule_4) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_4);
    children.push(_rule_4);
    i = _rule_4.last_index;
    _rule_4 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '</') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['closing'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== '>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 7,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (!(node => node.named.opening.value === node.named.closing.value)(node)) { return false; }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
virtual_node_1 = memoize('virtual_node_1', virtual_node_1);


let virtual_node_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'virtual_node',
    subRule: 2, type: 'virtual_node', named,
  };

  if (stream[i].type !== '<') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['opening'] = stream[i];
  children.push(stream[i]); i++;
  let _rule_2 = virtual_node_attributes(stream, i);
  while (_rule_2) {
    named['attrs'] ? null : named['attrs'] = [];
    named['attrs'].push(_rule_2);
    children.push(_rule_2);
    i = _rule_2.last_index;
    _rule_2 = virtual_node_attributes(stream, i);
  }

  if (stream[i].type !== '>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_4 = exp(stream, i);
  if (!_rule_4) return false;
  named['exp'] = _rule_4;
  children.push(_rule_4);
  i = _rule_4.last_index;

  if (stream[i].type !== '</') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['closing'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== '>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 7,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (!(node => node.named.opening.value === node.named.closing.value)(node)) { return false; }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
virtual_node_2 = memoize('virtual_node_2', virtual_node_2);


function virtual_node(stream, index) {
  return virtual_node_0(stream, index)
    || virtual_node_1(stream, index)
    || virtual_node_2(stream, index);
}
let virtual_node_exp_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'virtual_node_exp',
    subRule: 0, type: 'virtual_node_exp', named,
  };

  if (stream[i].type !== '<') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['opening'] = stream[i];
  children.push(stream[i]); i++;
  let _rule_2 = virtual_node_attributes(stream, i);
  while (_rule_2) {
    named['attrs'] ? null : named['attrs'] = [];
    named['attrs'].push(_rule_2);
    children.push(_rule_2);
    i = _rule_2.last_index;
    _rule_2 = virtual_node_attributes(stream, i);
  }
  if (stream[i].type === 'w') {
    children.push(stream[i]); i++;
  }

  if (stream[i].type !== '/>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
virtual_node_exp_0 = memoize('virtual_node_exp_0', virtual_node_exp_0);


let virtual_node_exp_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'virtual_node_exp',
    subRule: 1, type: 'virtual_node_exp', named,
  };

  if (stream[i].type !== '<') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['opening'] = stream[i];
  children.push(stream[i]); i++;
  let _rule_2 = virtual_node_attributes(stream, i);
  while (_rule_2) {
    named['attrs'] ? null : named['attrs'] = [];
    named['attrs'].push(_rule_2);
    children.push(_rule_2);
    i = _rule_2.last_index;
    _rule_2 = virtual_node_attributes(stream, i);
  }

  if (stream[i].type !== '>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_4 = SCOPED_STATEMENTS(stream, i);
  while (_rule_4) {
    named['stats'] ? null : named['stats'] = [];
    named['stats'].push(_rule_4);
    children.push(_rule_4);
    i = _rule_4.last_index;
    _rule_4 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '</') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['closing'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== '>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 7,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (!(node => node.named.opening.value === node.named.closing.value)(node)) { return false; }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
virtual_node_exp_1 = memoize('virtual_node_exp_1', virtual_node_exp_1);


let virtual_node_exp_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'virtual_node_exp',
    subRule: 2, type: 'virtual_node_exp', named,
  };

  if (stream[i].type !== '<') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['opening'] = stream[i];
  children.push(stream[i]); i++;
  let _rule_2 = virtual_node_attributes(stream, i);
  while (_rule_2) {
    named['attrs'] ? null : named['attrs'] = [];
    named['attrs'].push(_rule_2);
    children.push(_rule_2);
    i = _rule_2.last_index;
    _rule_2 = virtual_node_attributes(stream, i);
  }

  if (stream[i].type !== '>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_4 = exp(stream, i);
  if (!_rule_4) return false;
  named['exp'] = _rule_4;
  children.push(_rule_4);
  i = _rule_4.last_index;

  if (stream[i].type !== '</') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['closing'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== '>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_exp', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 7,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  if (!(node => node.named.opening.value === node.named.closing.value)(node)) { return false; }
  node.success = i === stream.length; node.last_index = i;
  return node;
};
virtual_node_exp_2 = memoize('virtual_node_exp_2', virtual_node_exp_2);


function virtual_node_exp(stream, index) {
  return virtual_node_exp_0(stream, index)
    || virtual_node_exp_1(stream, index)
    || virtual_node_exp_2(stream, index);
}
let virtual_node_assign_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'virtual_node_assign',
    subRule: 0, type: 'virtual_node_assign', named,
  };

  if (stream[i].type !== '=') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_assign', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_assign', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = exp(stream, i);
  if (!_rule_2) return false;
  named['exp'] = _rule_2;
  children.push(_rule_2);
  i = _rule_2.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
virtual_node_assign_0 = memoize('virtual_node_assign_0', virtual_node_assign_0);


function virtual_node_assign(stream, index) {
  return virtual_node_assign_0(stream, index);
}
let virtual_node_attributes_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'virtual_node_attributes',
    subRule: 0, type: 'virtual_node_attributes', named,
  };
  const _rule_0 = single_space_or_newline(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== 'attribute_name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_attributes', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== '=') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_attributes', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_3 = exp(stream, i);
  if (!_rule_3) return false;
  named['exp'] = _rule_3;
  children.push(_rule_3);
  i = _rule_3.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
virtual_node_attributes_0 = memoize('virtual_node_attributes_0', virtual_node_attributes_0);


let virtual_node_attributes_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'virtual_node_attributes',
    subRule: 1, type: 'virtual_node_attributes', named,
  };
  const _rule_0 = single_space_or_newline(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== 'attribute_name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_attributes', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
virtual_node_attributes_1 = memoize('virtual_node_attributes_1', virtual_node_attributes_1);


let virtual_node_attributes_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'virtual_node_attributes',
    subRule: 2, type: 'virtual_node_attributes', named,
  };
  const _rule_0 = single_space_or_newline(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_attributes', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== '=') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_attributes', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_3 = exp(stream, i);
  if (!_rule_3) return false;
  named['exp'] = _rule_3;
  children.push(_rule_3);
  i = _rule_3.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
virtual_node_attributes_2 = memoize('virtual_node_attributes_2', virtual_node_attributes_2);


let virtual_node_attributes_3 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'virtual_node_attributes',
    subRule: 3, type: 'virtual_node_attributes', named,
  };
  const _rule_0 = single_space_or_newline(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'virtual_node_attributes', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
virtual_node_attributes_3 = memoize('virtual_node_attributes_3', virtual_node_attributes_3);


function virtual_node_attributes(stream, index) {
  return virtual_node_attributes_0(stream, index)
    || virtual_node_attributes_1(stream, index)
    || virtual_node_attributes_2(stream, index)
    || virtual_node_attributes_3(stream, index);
}
let operation_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'operation',
    subRule: 0, type: 'operation', named,
  };

  if (stream[i].type !== 'math_operator') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'operation', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['math_op'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'operation', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = exp(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
operation_0 = memoize('operation_0', operation_0);


let operation_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'operation',
    subRule: 1, type: 'operation', named,
  };

  if (stream[i].type !== 'boolean_operator') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'operation', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['boolean_op'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'operation', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = exp(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
operation_1 = memoize('operation_1', operation_1);


let operation_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'operation',
    subRule: 2, type: 'operation', named,
  };

  if (stream[i].type !== '<') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'operation', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['boolean_op'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'operation', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = exp(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
operation_2 = memoize('operation_2', operation_2);


let operation_3 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'operation',
    subRule: 3, type: 'operation', named,
  };

  if (stream[i].type !== '>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'operation', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['boolean_op'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'operation', sub_rule_index: 3,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = exp(stream, i);
  if (!_rule_2) return false;
  children.push(_rule_2);
  i = _rule_2.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
operation_3 = memoize('operation_3', operation_3);


function operation(stream, index) {
  return operation_0(stream, index)
    || operation_1(stream, index)
    || operation_2(stream, index)
    || operation_3(stream, index);
}
let str_expression_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'str_expression',
    subRule: 0, type: 'str_expression', named,
  };

  if (stream[i].type !== 'str') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'str_expression', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['str'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_1 = inner_str_expression(stream, i);
  if (!_rule_1) return false;
  named['str_exp'] = _rule_1;
  children.push(_rule_1);
  i = _rule_1.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
str_expression_0 = memoize('str_expression_0', str_expression_0);


function str_expression(stream, index) {
  return str_expression_0(stream, index);
}
let inner_str_expression_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'inner_str_expression',
    subRule: 0, type: 'inner_str_expression', named,
  };
  const _rule_0 = exp(stream, i);
  if (!_rule_0) return false;
  named['exp'] = _rule_0;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== 'str') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'inner_str_expression', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['str'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_2 = inner_str_expression(stream, i);
  if (!_rule_2) return false;
  named['str_exp'] = _rule_2;
  children.push(_rule_2);
  i = _rule_2.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
inner_str_expression_0 = memoize('inner_str_expression_0', inner_str_expression_0);


let inner_str_expression_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'inner_str_expression',
    subRule: 1, type: 'inner_str_expression', named,
  };
  const _rule_0 = exp(stream, i);
  if (!_rule_0) return false;
  named['exp'] = _rule_0;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== 'str') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'inner_str_expression', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['str'] = stream[i];
  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
inner_str_expression_1 = memoize('inner_str_expression_1', inner_str_expression_1);


function inner_str_expression(stream, index) {
  return inner_str_expression_0(stream, index)
    || inner_str_expression_1(stream, index);
}
let try_catch_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'try_catch',
    subRule: 0, type: 'try_catch', named,
  };

  if (stream[i].type !== 'try') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'try_catch', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['try'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'try_catch', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_2 = SCOPED_STATEMENTS(stream, i);
  while (_rule_2) {
    named['statstry'] ? null : named['statstry'] = [];
    named['statstry'].push(_rule_2);
    children.push(_rule_2);
    i = _rule_2.last_index;
    _rule_2 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'try_catch', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'try_catch', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'catch') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'try_catch', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 5,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['catch'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'try_catch', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'try_catch', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 7,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '{') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'try_catch', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 8,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  let _rule_9 = SCOPED_STATEMENTS(stream, i);
  while (_rule_9) {
    named['statscatch'] ? null : named['statscatch'] = [];
    named['statscatch'].push(_rule_9);
    children.push(_rule_9);
    i = _rule_9.last_index;
    _rule_9 = SCOPED_STATEMENTS(stream, i);
  }

  if (stream[i].type !== '}') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'try_catch', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 10,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
try_catch_0 = memoize('try_catch_0', try_catch_0);


function try_catch(stream, index) {
  return try_catch_0(stream, index);
}
let access_or_operation_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'access_or_operation',
    subRule: 0, type: 'access_or_operation', named,
  };
  const _rule_0 = object_access(stream, i);
  if (!_rule_0) return false;
  named['access'] = _rule_0;
  children.push(_rule_0);
  i = _rule_0.last_index;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'access_or_operation', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 1,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_2 = operation(stream, i);
  if (!_rule_2) return false;
  named['op'] = _rule_2;
  children.push(_rule_2);
  i = _rule_2.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
access_or_operation_0 = memoize('access_or_operation_0', access_or_operation_0);


let access_or_operation_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'access_or_operation',
    subRule: 1, type: 'access_or_operation', named,
  };
  const _rule_0 = object_access(stream, i);
  if (!_rule_0) return false;
  named['access'] = _rule_0;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
access_or_operation_1 = memoize('access_or_operation_1', access_or_operation_1);


let access_or_operation_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'access_or_operation',
    subRule: 2, type: 'access_or_operation', named,
  };

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'access_or_operation', sub_rule_index: 2,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = operation(stream, i);
  if (!_rule_1) return false;
  named['op'] = _rule_1;
  children.push(_rule_1);
  i = _rule_1.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
access_or_operation_2 = memoize('access_or_operation_2', access_or_operation_2);


function access_or_operation(stream, index) {
  return access_or_operation_0(stream, index)
    || access_or_operation_1(stream, index)
    || access_or_operation_2(stream, index);
}
let name_exp_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'name_exp',
    subRule: 0, type: 'name_exp', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'name_exp', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_1 = access_or_operation(stream, i);
  if (!_rule_1) return false;
  named['access'] = _rule_1;
  children.push(_rule_1);
  i = _rule_1.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
name_exp_0 = memoize('name_exp_0', name_exp_0);


let name_exp_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'name_exp',
    subRule: 1, type: 'name_exp', named,
  };

  if (stream[i].type !== 'name') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'name_exp', sub_rule_index: 1,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['name'] = stream[i];
  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
name_exp_1 = memoize('name_exp_1', name_exp_1);


function name_exp(stream, index) {
  return name_exp_0(stream, index)
    || name_exp_1(stream, index);
}
let if_expression_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'if_expression',
    subRule: 0, type: 'if_expression', named,
  };
  const _rule_0 = condition(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
if_expression_0 = memoize('if_expression_0', if_expression_0);


function if_expression(stream, index) {
  return if_expression_0(stream, index);
}
let short_if_expression_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'short_if_expression',
    subRule: 0, type: 'short_if_expression', named,
  };

  if (stream[i].type !== 'if') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'short_if_expression', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['type'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (!_rule_1) return false;
  named['exp1'] = _rule_1;
  children.push(_rule_1);
  i = _rule_1.last_index;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'short_if_expression', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== '=>') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'short_if_expression', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 3,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'short_if_expression', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 4,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_5 = exp(stream, i);
  if (!_rule_5) return false;
  named['exp2'] = _rule_5;
  children.push(_rule_5);
  i = _rule_5.last_index;

  if (stream[i].type !== 'w') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'short_if_expression', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 6,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;

  if (stream[i].type !== 'else') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'short_if_expression', sub_rule_index: 0,
        sub_rule_stream_index: i - index, sub_rule_token_index: 7,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  named['else'] = stream[i];
  children.push(stream[i]); i++;
  const _rule_8 = exp(stream, i);
  if (!_rule_8) return false;
  named['exp3'] = _rule_8;
  children.push(_rule_8);
  i = _rule_8.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
short_if_expression_0 = memoize('short_if_expression_0', short_if_expression_0);


function short_if_expression(stream, index) {
  return short_if_expression_0(stream, index);
}
let exp_0 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 0, type: 'exp', named,
  };
  const _rule_0 = name_exp(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_0 = memoize('exp_0', exp_0);


let exp_1 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 1, type: 'exp', named,
  };
  const _rule_0 = exp(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  const _rule_1 = access_or_operation(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_1 = memoize_left_recur('exp_1', exp_1);


let exp_2 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 2, type: 'exp', named,
  };
  const _rule_0 = func_def(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_2 = memoize('exp_2', exp_2);


let exp_3 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 3, type: 'exp', named,
  };
  const _rule_0 = named_func_call(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_3 = memoize('exp_3', exp_3);


let exp_4 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 4, type: 'exp', named,
  };

  if (stream[i].type !== 'number') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'exp', sub_rule_index: 4,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_4 = memoize('exp_4', exp_4);


let exp_5 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 5, type: 'exp', named,
  };
  const _rule_0 = str_expression(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_5 = memoize('exp_5', exp_5);


let exp_6 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 6, type: 'exp', named,
  };

  if (stream[i].type !== 'str') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'exp', sub_rule_index: 6,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_6 = memoize('exp_6', exp_6);


let exp_7 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 7, type: 'exp', named,
  };

  if (stream[i].type !== 'regexp') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'exp', sub_rule_index: 7,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_7 = memoize('exp_7', exp_7);


let exp_8 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 8, type: 'exp', named,
  };

  if (stream[i].type !== '(') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'exp', sub_rule_index: 8,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;

  if (stream[i].type !== ')') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'exp', sub_rule_index: 8,
        sub_rule_stream_index: i - index, sub_rule_token_index: 2,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_8 = memoize('exp_8', exp_8);


let exp_9 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 9, type: 'exp', named,
  };

  if (stream[i].type !== 'operand') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'exp', sub_rule_index: 9,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_9 = memoize('exp_9', exp_9);


let exp_10 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 10, type: 'exp', named,
  };

  if (stream[i].type !== 'unary') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'exp', sub_rule_index: 10,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_10 = memoize('exp_10', exp_10);


let exp_11 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 11, type: 'exp', named,
  };
  const _rule_0 = object_literal(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_11 = memoize('exp_11', exp_11);


let exp_12 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 12, type: 'exp', named,
  };
  const _rule_0 = array_literal(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_12 = memoize('exp_12', exp_12);


let exp_13 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 13, type: 'exp', named,
  };

  if (stream[i].type !== 'await') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'exp', sub_rule_index: 13,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_13 = memoize('exp_13', exp_13);


let exp_14 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 14, type: 'exp', named,
  };
  const _rule_0 = virtual_node_assign(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_14 = memoize('exp_14', exp_14);


let exp_15 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 15, type: 'exp', named,
  };
  const _rule_0 = virtual_node_exp(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_15 = memoize('exp_15', exp_15);


let exp_16 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 16, type: 'exp', named,
  };

  if (stream[i].type !== 'new') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'exp', sub_rule_index: 16,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_16 = memoize('exp_16', exp_16);


let exp_17 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 17, type: 'exp', named,
  };

  if (stream[i].type !== 'throw') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'exp', sub_rule_index: 17,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_17 = memoize('exp_17', exp_17);


let exp_18 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 18, type: 'exp', named,
  };

  if (stream[i].type !== 'delete') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'exp', sub_rule_index: 18,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_18 = memoize('exp_18', exp_18);


let exp_19 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 19, type: 'exp', named,
  };

  if (stream[i].type !== 'spread') {
    if (i >= best_failure_index) {
      const failure = {
        rule_name: 'exp', sub_rule_index: 19,
        sub_rule_stream_index: i - index, sub_rule_token_index: 0,
        stream_index: i, token: stream[i], first_token: stream[index], success: false,
      };
      record_failure(failure, i);
    }
    return false;
  }

  children.push(stream[i]); i++;
  const _rule_1 = exp(stream, i);
  if (!_rule_1) return false;
  children.push(_rule_1);
  i = _rule_1.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_19 = memoize('exp_19', exp_19);


let exp_20 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 20, type: 'exp', named,
  };
  const _rule_0 = if_expression(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_20 = memoize('exp_20', exp_20);


let exp_21 = (stream, index) => {
  let i = index;
  const children = [];
  const named = {};
  const node = {
    children, stream_index: index, name: 'exp',
    subRule: 21, type: 'exp', named,
  };
  const _rule_0 = short_if_expression(stream, i);
  if (!_rule_0) return false;
  children.push(_rule_0);
  i = _rule_0.last_index;
  node.success = i === stream.length; node.last_index = i;
  return node;
};
exp_21 = memoize('exp_21', exp_21);


function exp(stream, index) {
  return exp_0(stream, index)
    || exp_1(stream, index)
    || exp_2(stream, index)
    || exp_3(stream, index)
    || exp_4(stream, index)
    || exp_5(stream, index)
    || exp_6(stream, index)
    || exp_7(stream, index)
    || exp_8(stream, index)
    || exp_9(stream, index)
    || exp_10(stream, index)
    || exp_11(stream, index)
    || exp_12(stream, index)
    || exp_13(stream, index)
    || exp_14(stream, index)
    || exp_15(stream, index)
    || exp_16(stream, index)
    || exp_17(stream, index)
    || exp_18(stream, index)
    || exp_19(stream, index)
    || exp_20(stream, index)
    || exp_21(stream, index);
}
function _tokenize(tokenDef, input, stream) {
  let match;
  match = input.match(tokenDef.number.reg);
  if (match !== null) {
    return [match[0], 'number'];
  }
  match = input.match(tokenDef.comment.reg);
  if (match !== null) {
    return [match[0], 'comment'];
  }
  match = input.match(tokenDef.multiline_comment.reg);
  if (match !== null) {
    return [match[0], 'multiline_comment'];
  }
  if (input.startsWith('as ')) {
    return ['as ', 'as'];
  }
  if (input.startsWith('class ')) {
    return ['class ', 'clazz'];
  }
  if (input.startsWith('try ')) {
    return ['try ', 'try'];
  }
  if (input.startsWith('catch ')) {
    return ['catch ', 'catch'];
  }
  if (input.startsWith('def ')) {
    return ['def ', 'def'];
  }
  if (input.startsWith('new ')) {
    return ['new ', 'new'];
  }
  if (input.startsWith('delete ')) {
    return ['delete ', 'delete'];
  }
  if (input.startsWith('if ')) {
    return ['if ', 'if'];
  }
  if (input.startsWith('while ')) {
    return ['while ', 'while'];
  }
  if (input.startsWith('else ')) {
    return ['else ', 'else'];
  }
  if (input.startsWith('for ')) {
    return ['for ', 'for'];
  }
  if (input.startsWith('in ')) {
    return ['in ', 'in'];
  }
  if (input.startsWith('await ')) {
    return ['await ', 'await'];
  }
  if (input.startsWith('async ')) {
    return ['async ', 'async'];
  }
  if (input.startsWith('extends ')) {
    return ['extends ', 'extends'];
  }
  if (input.startsWith('elseif ')) {
    return ['elseif ', 'elseif'];
  }
  match = tokenDef.return.func(input, stream);
  if (match !== undefined) {
    return [match, 'return'];
  }
  match = tokenDef.break.func(input, stream);
  if (match !== undefined) {
    return [match, 'break'];
  }
  match = tokenDef.continue.func(input, stream);
  if (match !== undefined) {
    return [match, 'continue'];
  }
  if (input.startsWith('throw ')) {
    return ['throw ', 'throw'];
  }
  if (input.startsWith('import ')) {
    return ['import ', 'import'];
  }
  if (input.startsWith('...')) {
    return ['...', 'spread'];
  }
  if (input.startsWith('from ')) {
    return ['from ', 'from'];
  }
  match = input.match(tokenDef.operand.reg);
  if (match !== null) {
    return [match[0], 'operand'];
  }
  if (input.startsWith(',')) {
    return [',', ','];
  }
  if (input.startsWith('.')) {
    return ['.', '.'];
  }
  if (input.startsWith('(')) {
    return ['(', '('];
  }
  if (input.startsWith(')')) {
    return [')', ')'];
  }
  if (input.startsWith('{')) {
    return ['{', '{'];
  }
  if (input.startsWith('}')) {
    return ['}', '}'];
  }
  if (input.startsWith('</')) {
    return ['</', '</'];
  }
  if (input.startsWith('/>')) {
    return ['/>', '/>'];
  }
  if (input.startsWith('[')) {
    return ['[', '['];
  }
  if (input.startsWith(']')) {
    return [']', ']'];
  }
  if (input.startsWith('=>')) {
    return ['=>', '=>'];
  }
  match = input.match(tokenDef.boolean_operator.reg);
  if (match !== null) {
    return [match[0], 'boolean_operator'];
  }
  if (input.startsWith('>')) {
    return ['>', '>'];
  }
  if (input.startsWith('<')) {
    return ['<', '<'];
  }
  match = input.match(tokenDef.attribute_name.reg);
  if (match !== null) {
    return [match[0], 'attribute_name'];
  }
  match = input.match(tokenDef.name.reg);
  if (match !== null) {
    return [match[0], 'name'];
  }
  match = tokenDef.regexp.func(input, stream);
  if (match !== undefined) {
    return [match, 'regexp'];
  }
  match = input.match(tokenDef.math_operator.reg);
  if (match !== null) {
    return [match[0], 'math_operator'];
  }
  if (input.startsWith('!')) {
    return ['!', 'unary'];
  }
  if (input.startsWith(':=')) {
    return [':=', 'explicit_assign'];
  }
  if (input.startsWith('=')) {
    return ['=', '='];
  }
  if (input.startsWith(':')) {
    return [':', 'colon'];
  }
  if (input.startsWith(`
`)) {
    return [`
`, 'newline'];
  }
  match = tokenDef.str.func(input, stream);
  if (match !== undefined) {
    return [match, 'str'];
  }
  match = tokenDef.w.func(input, stream);
  if (match !== undefined) {
    return [match, 'w'];
  }
  match = input.match(tokenDef.W.reg);
  if (match !== null) {
    return [match[0], 'W'];
  }
  return [null, 'W'];
}
function tokenize(tokenDef, input) {
  const stream = [];
  let lastToken;
  let key;
  let candidate = null;
  const len = input.length;
  let char = 0;
  let index = 0;
  let line = 0;
  let column = 0;
  while (char < len) {
    [candidate, key] = _tokenize(tokenDef, input, stream);
    if (candidate !== null) {
      lastToken = {
        type: key,
        value: candidate,
        start: char,
        stream_index: index,
        len: candidate.length,
        lineStart: line,
        columnStart: column,
      };
      const lines = candidate.split('\n');
      if (lines.length > 1) {
        line += lines.length - 1;
        column = lines[lines.length - 1].length;
      } else {
        column += candidate.length;
      }
      lastToken.lineEnd = line;
      lastToken.columnEnd = column;
      stream.push(lastToken);
      index++;
      char += candidate.length;
      input = input.substr(candidate.length);
    } else {
      if (stream.length === 0) {
        throw new Error('Tokenizer error: total match failure');
      }
      if (lastToken) {
        lastToken.pointer += lastToken.value.length;
      }
      let msg = `Tokenizer error, no matching token found for ${input.slice(0, 26)}`;
      if (lastToken) {
        msg += `Before token of type ${lastToken.type}: ${lastToken.value}`;
      }
      const error = new Error(msg);
      error.token = lastToken;
      throw error;
    }
  }
  stream.push({
    type: 'EOS', value: '<End Of Stream>', char, index,
  });
  return stream;
}

module.exports = {
  parse: (stream) => {
    best_failure = null;
    best_failure_index = 0;
    best_failure_array = [];
    cache = {};
    cacheR = {};
    const result = START(stream, 0);
    if (!result) {
      return best_failure;
    }
    return result;
  },
  tokenize,
};
