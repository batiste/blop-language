The directory `vscode/blop-linter/blop-linter/server/src` is auto-generated by `npm run linter`. Do not modify any files in this directory except `server.ts`.

For positive tests, prefer writing real `.blop` test files that are compiled by the test suite. For negative tests, use `expectCompilationError` from `src/tests/testHelpers.js`.

When asked to do a task, start by writing a test that captures the expected behavior and the failing cases for each edge case.

Prefer clean solution to quick hacks. When in doubt, ask for a review. Write tests to clarify complex logic rather than infer too much from code. Execute tests often to control your assertion about the code behavior. Check for refactoring opportunities to reduce complexity and code size.

Always use ESM imports, even in test files.

Use camelCase for files.

When you write md docs, avoid excessive emoticons. Use typescript as the code block language for proper coloration.

For AST debugging during type inference investigations, use the reusable debug utilities in `src/tests/debugUtils.js`. Functions like `findNodes()`, `analyzeOperations()`, `printInferenceTree()` help explore AST structure and type inference without writing throwaway scripts.

## Running debug scripts

`compileSource` does NOT expose the AST. To inspect it, use `parser` and `inference` directly:

```typescript
import parser from '../parser.js';
import { tokensDefinition } from '../tokensDefinition.js';
import { inference } from '../inference/index.js';
import { findNodes, printNode } from './debugUtils.js';

const stream = parser.tokenize(tokensDefinition, src);
const ast = parser.parse(stream);
inference(ast, stream, 'debug.blop');
// now ast nodes have .inferredType stamped on them
```

Run with: `node --experimental-vm-modules src/tests/yourDebugFile.js`

## Type inference architecture

Two-phase design: **inference** (phase 2) propagates types silently — warnings are suppressed so partial information mid-traversal doesn't produce false positives. **Checking** (phase 3) re-walks the same AST with the same handlers and emits warnings. Both phases run with fresh scopes initialised from the binding phase symbol table. A bug that only manifests in one phase usually means the handler is doing the wrong thing for that phase — check `inferencePhase === 'checking'` guards.

## LiteralType vs PrimitiveType

Variables without type annotations get a `LiteralType` (e.g. `x = 5` → `LiteralType(5, NumberType)`), not a bare `PrimitiveType`. Any check using `instanceof PrimitiveType` will miss inferred literals. Always use `getBaseTypeOfLiteral(type)` (from `typeSystem.js`) to normalise before comparing kinds. This applies in `checkMathOperation`, property access guards, and anywhere types from inferred variables are consumed.

## Grammar and AST structure

The grammar is defined in `src/grammar.js`. The named key for a node in the AST matches the `:label` in the grammar rule. For example `type_arguments:type_args` means the node is stored at `.named.type_args`, NOT `.named.type_arguments`.

The grammar is recursive. Each grammar alternative consumes one "step", so chained calls nest: `node.useState<number>('count', 0)` produces:

```
access_or_operation
  named.access → object_access (OUTER: '.' + name="useState")
    child object_access (INNER: type_arguments + func_call)
      named.type_args → type_arguments
        named.args → type_argument_list
          named.arg → type_expression
```