The directory `vscode/blop-linter/blop-linter/server/src` is auto-generated by `npm run linter`. Do not modify any files in this directory except `server.ts`.

For positive tests, prefer writing real `.blop` test files that are compiled by the test suite. For negative tests, use `expectCompilationError` from `src/tests/testHelpers.js`.

When asked to do a task, start by writing a test that captures the expected behavior and the failing cases for each edge case.

Prefer clean solution to quick hacks. When in doubt, ask for a review. Write tests to clarify complex logic rather than infer too much from code. Execute tests often to control your assertion about the code behavior. Check for refactoring opportunities to reduce complexity and code size.

Always use ESM imports, even in test files.

Use camelCase for files.

When you write md docs, avoid excessive emoticons. Use typescript as the code block language for proper coloration.

For AST debugging during type inference investigations, use the reusable debug utilities in `src/tests/debugUtils.js`. Functions like `findNodes()`, `analyzeOperations()`, `printInferenceTree()` help explore AST structure and type inference without writing throwaway scripts.

## Running debug scripts

`compileSource` does NOT expose the AST. To inspect it, use `parser` and `inference` directly:

```typescript
import parser from '../parser.js';
import { tokensDefinition } from '../tokensDefinition.js';
import { inference } from '../inference/index.js';
import { findNodes, printNode } from './debugUtils.js';

const stream = parser.tokenize(tokensDefinition, src);
const ast = parser.parse(stream);
inference(ast, stream, 'debug.blop');
// now ast nodes have .inferredType stamped on them
```

Run with: `node --experimental-vm-modules src/tests/yourDebugFile.js`

## Grammar and AST structure

The grammar is defined in `src/grammar.js`. The named key for a node in the AST matches the `:label` in the grammar rule. For example `type_arguments:type_args` means the node is stored at `.named.type_args`, NOT `.named.type_arguments`.

The grammar is recursive. Each grammar alternative consumes one "step", so chained calls nest: `node.useState<number>('count', 0)` produces:

```
access_or_operation
  named.access → object_access (OUTER: '.' + name="useState")
    child object_access (INNER: type_arguments + func_call)
      named.type_args → type_arguments
        named.args → type_argument_list
          named.arg → type_expression
```